<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>MegaConsole 30 - Ultimate Gaming Experience</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e, #0f3460);
            overflow: hidden;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        .console-container {
            display: flex;
            height: 100vh;
            background: #1a1a2a;
            position: relative;
        }
        
        .sidebar {
            width: 280px;
            background: linear-gradient(180deg, #2a2a3a, #1a1a2a);
            border-right: 3px solid #00ff64;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .logo {
            padding: 20px;
            text-align: center;
            color: #00ff64;
            font-size: 14px;
            text-shadow: 0 0 20px #00ff64;
            border-bottom: 2px solid #00ff64;
            animation: logoGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes logoGlow {
            from { text-shadow: 0 0 20px #00ff64; }
            to { text-shadow: 0 0 40px #00ff64, 0 0 60px #00ff64; }
        }
        
        .game-carousel {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .game-category {
            margin-bottom: 20px;
        }
        
        .category-title {
            color: #ffff64;
            font-size: 10px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ffff64;
            border-bottom: 1px solid #ffff64;
            padding-bottom: 5px;
        }
        
        .game-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .game-card {
            background: linear-gradient(45deg, #2a4a2a, #1a3a1a);
            border: 2px solid #00ff64;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .game-card:hover, .game-card.active {
            transform: translateY(-3px);
            box-shadow: 0 0 20px rgba(0,255,100,0.6);
            background: linear-gradient(45deg, #3a5a3a, #2a4a2a);
        }
        
        .game-card.active {
            border-color: #ffff64;
            box-shadow: 0 0 25px rgba(255,255,100,0.8);
        }
        
        .game-icon {
            font-size: 20px;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .game-title {
            font-size: 7px;
            text-align: center;
            color: #00ff64;
            line-height: 1.2;
        }
        
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .game-display {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .game-canvas {
            border: 4px solid #00ff64;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(0,255,100,0.5);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .controls-bar {
            height: 120px;
            background: linear-gradient(180deg, #2a2a3a, #1a1a2a);
            border-top: 3px solid #ff6464;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
        }
        
        .dpad {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 3px;
            width: 90px;
            height: 90px;
        }
        
        .dpad-btn {
            background: linear-gradient(45deg, #4a2a2a, #3a1a1a);
            border: 2px solid #ff6464;
            color: #ff6464;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        
        .dpad-btn:hover {
            background: linear-gradient(45deg, #5a3a3a, #4a2a2a);
            box-shadow: 0 0 10px rgba(255,100,100,0.5);
        }
        
        .dpad-btn:active {
            transform: scale(0.95);
            background: linear-gradient(45deg, #6a4a4a, #5a3a3a);
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(45deg, #2a2a4a, #1a1a3a);
            border: 3px solid #6464ff;
            color: #6464ff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P';
        }
        
        .action-btn:hover {
            background: linear-gradient(45deg, #3a3a5a, #2a2a4a);
            box-shadow: 0 0 15px rgba(100,100,255,0.5);
        }
        
        .action-btn:active {
            transform: scale(0.9);
        }
        
        .system-controls {
            display: flex;
            gap: 8px;
        }
        
        .system-btn {
            padding: 8px 12px;
            background: linear-gradient(45deg, #4a4a2a, #3a3a1a);
            border: 2px solid #ffff64;
            color: #ffff64;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 8px;
            font-family: 'Press Start 2P';
        }
        
        .system-btn:hover {
            background: linear-gradient(45deg, #5a5a3a, #4a4a2a);
            box-shadow: 0 0 10px rgba(255,255,100,0.5);
        }
        
        .game-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            color: #00ff64;
            font-size: 10px;
            max-width: 200px;
            border: 2px solid #00ff64;
        }
        
        .hud-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffff64;
            font-size: 12px;
            text-shadow: 0 0 10px #ffff64;
            z-index: 100;
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Orbitron', monospace;
            z-index: 200;
        }
        
        .overlay-title {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #fff;
            animation: overlayPulse 2s ease-in-out infinite;
        }
        
        @keyframes overlayPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000, #222, #000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff64;
            font-family: 'Orbitron', monospace;
            z-index: 300;
        }
        
        .loading-bar {
            width: 400px;
            height: 20px;
            border: 2px solid #00ff64;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            margin-top: 20px;
        }
        
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff64, #64ff64, #00ff64);
            width: 0%;
            transition: width 0.3s ease;
            animation: loadingShine 2s ease-in-out infinite;
        }
        
        @keyframes loadingShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* Мобильная адаптация */
        @media (max-width: 768px) {
            .console-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 200px;
                border-right: none;
                border-bottom: 3px solid #00ff64;
            }
            
            .game-carousel {
                overflow-x: auto;
                overflow-y: hidden;
            }
            
            .game-grid {
                display: flex;
                gap: 8px;
                padding-bottom: 10px;
            }
            
            .game-card {
                min-width: 80px;
                flex-shrink: 0;
            }
            
            .controls-bar {
                height: 100px;
                padding: 10px;
            }
            
            .dpad {
                width: 70px;
                height: 70px;
            }
            
            .action-btn {
                width: 40px;
                height: 40px;
                font-size: 8px;
            }
        }
        
        @media (max-width: 480px) {
            .logo {
                padding: 10px;
                font-size: 10px;
            }
            
            .controls-bar {
                height: 80px;
                padding: 8px;
            }
            
            .dpad {
                width: 60px;
                height: 60px;
            }
            
            .dpad-btn {
                font-size: 10px;
            }
            
            .action-btn {
                width: 35px;
                height: 35px;
                font-size: 7px;
            }
            
            .system-btn {
                padding: 6px 8px;
                font-size: 6px;
            }
        }
        
        /* Дополнительные анимации */
        .particle-effect {
            position: absolute;
            pointer-events: none;
            z-index: 150;
        }
        
        .game-transition {
            animation: gameTransition 0.5s ease-in-out;
        }
        
        @keyframes gameTransition {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        /* Улучшенные эффекты для Тетриса */
        .tetris-enhanced {
            filter: drop-shadow(0 0 10px #00ff64);
        }
        
        .combo-effect {
            position: absolute;
            color: #ffff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 20px #ffff00;
            animation: comboFloat 1s ease-out forwards;
            z-index: 100;
        }
        
        @keyframes comboFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }
    </style>
</head>
<body>
    <div class="console-container">
        <div class="sidebar">
            <div class="logo">
                🎮 MEGACONSOLE 30<br>
                ULTIMATE EDITION
            </div>
            
            <div class="game-carousel">
                <div class="game-category">
                    <div class="category-title">🧩 КЛАССИЧЕСКИЕ ГОЛОВОЛОМКИ</div>
                    <div class="game-grid" id="puzzleGames"></div>
                </div>
                
                <div class="game-category">
                    <div class="category-title">🚗 АРКАДЫ И ГОНКИ</div>
                    <div class="game-grid" id="arcadeGames"></div>
                </div>
                
                <div class="game-category">
                    <div class="category-title">🚀 ЭКШН И ШУТЕРЫ</div>
                    <div class="game-grid" id="actionGames"></div>
                </div>
                
                <div class="game-category">
                    <div class="category-title">⭐ АВТОРСКИЕ НОВИНКИ</div>
                    <div class="game-grid" id="originalGames"></div>
                </div>
            </div>
        </div>
        
        <div class="main-area">
            <div class="game-display">
                <canvas class="game-canvas" id="gameCanvas" width="800" height="600"></canvas>
                
                <div class="hud-overlay" id="gameHUD">
                    <div>SCORE: <span id="score">000000</span></div>
                    <div>LEVEL: <span id="level">01</span></div>
                    <div>LIVES: <span id="lives">3</span></div>
                </div>
                
                <div class="game-info" id="gameInfo">
                    <div style="color: #ffff64; margin-bottom: 5px;">GAME INFO</div>
                    <div id="gameDescription">Выберите игру из списка слева для начала. Используйте D-Pad для управления и кнопки действий.</div>
                </div>
                
                <div class="game-overlay" id="gameOverlay">
                    <div class="overlay-title" id="overlayTitle">GAME READY</div>
                    <div id="overlayText">Press START to begin</div>
                </div>
                
                <div class="loading-screen" id="loadingScreen">
                    <div style="font-size: 28px; margin-bottom: 10px;">⚡ LOADING GAME ⚡</div>
                    <div style="font-size: 16px;" id="loadingText">Initializing...</div>
                    <div class="loading-bar">
                        <div class="loading-fill" id="loadingFill"></div>
                    </div>
                </div>
            </div>
            
            <div class="controls-bar">
                <div class="dpad">
                    <div></div>
                    <div class="dpad-btn" data-key="ArrowUp">▲</div>
                    <div></div>
                    <div class="dpad-btn" data-key="ArrowLeft">◄</div>
                    <div class="dpad-btn" data-key="Space">●</div>
                    <div class="dpad-btn" data-key="ArrowRight">►</div>
                    <div></div>
                    <div class="dpad-btn" data-key="ArrowDown">▼</div>
                    <div></div>
                </div>
                
                <div class="action-buttons">
                    <div class="action-btn" data-key="KeyA">A</div>
                    <div class="action-btn" data-key="KeyB">B</div>
                    <div class="action-btn" data-key="KeyX">X</div>
                    <div class="action-btn" data-key="KeyY">Y</div>
                </div>
                
                <div class="system-controls">
                    <div class="system-btn" id="startBtn">START</div>
                    <div class="system-btn" id="pauseBtn">PAUSE</div>
                    <div class="system-btn" id="resetBtn">RESET</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Настройка canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Звуковая система
        class AdvancedSoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterVolume = 0.3;
                this.sounds = {};
                this.initAudio();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
            
            createTone(frequency, duration, type = 'square', volume = 1, envelope = null) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(frequency * 2, this.audioContext.currentTime);
                
                if (envelope) {
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * volume, this.audioContext.currentTime + envelope.attack);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * volume * envelope.sustain, this.audioContext.currentTime + envelope.attack + envelope.decay);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                } else {
                    gainNode.gain.setValueAtTime(this.masterVolume * volume, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                }
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            playMove() { this.createTone(440, 0.1, 'square'); }
            playRotate() { this.createTone(660, 0.15, 'square'); }
            playDrop() { this.createTone(220, 0.2, 'triangle'); }
            playLineClear() { 
                const notes = [523, 659, 784, 1047];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.createTone(freq, 0.25, 'square'), i * 80);
                });
            }
            playTetris() {
                const melody = [523, 659, 784, 1047, 784, 659, 523, 440];
                melody.forEach((freq, i) => {
                    setTimeout(() => this.createTone(freq, 0.2, 'square'), i * 120);
                });
            }
            playGameOver() {
                const notes = [440, 415, 392, 370, 349, 330, 311, 294];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.createTone(freq, 0.4, 'sawtooth'), i * 200);
                });
            }
            playLevelUp() {
                const notes = [523, 659, 784, 1047, 1319];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.createTone(freq, 0.25, 'triangle'), i * 100);
                });
            }
            playShoot() { this.createTone(800, 0.15, 'square'); }
            playExplosion() { this.createTone(150, 0.5, 'sawtooth'); }
            playJump() { this.createTone(880, 0.2, 'square'); }
            playPickup() { this.createTone(1200, 0.2, 'triangle'); }
        }
        
        const soundSystem = new AdvancedSoundSystem();
        
        // Список всех игр (30 штук)
        const allGames = {
            puzzle: [
                { id: 'tetris', title: 'TETRIS\nPRO', icon: '🧩', description: 'Улучшенный классический Тетрис с новыми эффектами, комбо-системой и плавной анимацией.' },
                { id: 'snake', title: 'SNAKE\nDELUXE', icon: '🐍', description: 'Змейка с улучшенной графикой, бонусами и специальными эффектами.' },
                { id: 'breakout', title: 'BRICK\nBREAKER', icon: '🧱', description: 'Арканоид с множественными мячами, бонусами и разрушаемыми блоками.' },
                { id: 'match3', title: 'JEWEL\nCRUSH', icon: '💎', description: 'Три в ряд с каскадными комбо и взрывными эффектами.' },
                { id: 'sokoban', title: 'BOX\nPUSHER', icon: '📦', description: 'Головоломка с ящиками и переключателями на 50 уровнях.' },
                { id: 'pipes', title: 'PIPE\nCONNECT', icon: '🔧', description: 'Соединяйте трубы для создания непрерывного потока воды.' },
                { id: 'sudoku', title: 'NUMBER\nGRID', icon: '🔢', description: 'Судоку с подсказками и проверкой ошибок.' },
                { id: 'minesweeper', title: 'MINE\nFIELD', icon: '💣', description: 'Сапёр с настраиваемой сложностью и режимом скорости.' }
            ],
            arcade: [
                { id: 'racing', title: 'SUPER\nRACER', icon: '🏎️', description: 'Высокоскоростные гонки с препятствиями и бонусами.' },
                { id: 'pacman', title: 'DOT\nEATER', icon: '👻', description: 'Пакман с новыми лабиринтами и усиленными привидениями.' },
                { id: 'frogger', title: 'ROAD\nHOPPER', icon: '🐸', description: 'Переходите дороги и реки, избегая опасностей.' },
                { id: 'centipede', title: 'BUG\nBLASTER', icon: '🐛', description: 'Стреляйте по насекомым, спускающимся сверху.' },
                { id: 'qbert', title: 'CUBE\nHOPPER', icon: '🎲', description: 'Прыгайте по кубам, меняя их цвет.' },
                { id: 'dkong', title: 'BARREL\nJUMP', icon: '🦍', description: 'Избегайте бочек и поднимайтесь вверх.' },
                { id: 'tron', title: 'LIGHT\nCYCLE', icon: '🌐', description: 'Гонки на световых мотоциклах с энергетическими следами.' }
            ],
            action: [
                { id: 'tanks', title: 'BATTLE\nCITY', icon: '🚀', description: 'Танковые бои с разрушаемой средой и боссами.' },
                { id: 'spaceshooter', title: 'GALAGA\nWARS', icon: '🚀', description: 'Космический шутер с волнами врагов и апгрейдами.' },
                { id: 'asteroids', title: 'METEOR\nSTORM', icon: '🌌', description: 'Уничтожайте астероиды в открытом космосе.' },
                { id: 'platformer', title: 'PIXEL\nHERO', icon: '🦘', description: 'Платформер с коллекционированием и секретными зонами.' },
                { id: 'defender', title: 'PLANET\nGUARD', icon: '🛸', description: 'Защищайте планету от вторжения пришельцев.' },
                { id: 'contra', title: 'JUNGLE\nWAR', icon: '🔫', description: 'Бег и стрельба в джунглях против армии врагов.' },
                { id: 'gradius', title: 'SPACE\nFORCE', icon: '✈️', description: 'Горизонтальный шутер с системой улучшений.' }
            ],
            original: [
                { id: 'quantum', title: 'QUANTUM\nSHIFT', icon: '⚛️', description: 'Управляйте квантовыми частицами в многомерном пространстве.' },
                { id: 'gravity', title: 'GRAVITY\nWELL', icon: '🌀', description: 'Используйте гравитацию для решения космических головоломок.' },
                { id: 'timewarp', title: 'TIME\nWARP', icon: '⏰', description: 'Манипулируйте временем для прохождения уровней.' },
                { id: 'neonrun', title: 'NEON\nRUNNER', icon: '🌈', description: 'Бегите по неоновым дорожкам под электронную музыку.' },
                { id: 'synthwave', title: 'SYNTH\nWAVE', icon: '🎵', description: 'Ритм-игра в стиле 80х с синтезаторными мелодиями.' },
                { id: 'pixelart', title: 'PIXEL\nPAINT', icon: '🎨', description: 'Создавайте пиксельное искусство под ограничения времени.' },
                { id: 'codebreak', title: 'CODE\nBREAK', icon: '💻', description: 'Взламывайте системы, решая логические головоломки.' },
                { id: 'dreamscape', title: 'DREAM\nSCAPE', icon: '💭', description: 'Путешествуйте по сюрреалистическим мирам снов.' }
            ]
        };
        
        // Глобальное состояние
        let currentGame = null;
        let activeGameInstance = null;
        let gameRunning = false;
        let keys = {};
        
        // Базовый класс для всех игр
        class BaseGame {
            constructor() {
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.running = false;
                this.paused = false;
            }
            
            init() {
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.updateHUD();
                this.setupGame();
            }
            
            setupGame() {}
            
            start() {
                this.running = true;
                this.paused = false;
                this.gameLoop();
            }
            
            stop() {
                this.running = false;
            }
            
            pause() {
                this.paused = !this.paused;
            }
            
            gameLoop() {
                if (!this.running) return;
                
                if (!this.paused) {
                    this.update();
                    this.draw();
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {}
            draw() {}
            
            updateHUD() {
                document.getElementById('score').textContent = this.score.toString().padStart(6, '0');
                document.getElementById('level').textContent = this.level.toString().padStart(2, '0');
                document.getElementById('lives').textContent = this.lives;
            }
            
            gameOver() {
                this.running = false;
                soundSystem.playGameOver();
                showOverlay('GAME OVER', `FINAL SCORE: ${this.score}`);
            }
        }
        
        // Улучшенный Тетрис
        class EnhancedTetrisGame extends BaseGame {
            constructor() {
                super();
                this.BOARD_WIDTH = 10;
                this.BOARD_HEIGHT = 20;
                this.CELL_SIZE = 30;
                this.board = [];
                this.currentPiece = null;
                this.nextPiece = null;
                this.heldPiece = null;
                this.canHold = true;
                this.fallTime = 0;
                this.fallSpeed = 800;
                this.lines = 0;
                this.combo = 0;
                this.particles = [];
                this.ghostPiece = null;
                
                this.tetrominoes = {
                    I: { shape: [[1,1,1,1]], color: '#00FFFF', glow: '#00FFFF' },
                    O: { shape: [[1,1],[1,1]], color: '#FFFF00', glow: '#FFFF00' },
                    T: { shape: [[0,1,0],[1,1,1]], color: '#AA00FF', glow: '#AA00FF' },
                    S: { shape: [[0,1,1],[1,1,0]], color: '#00FF00', glow: '#00FF00' },
                    Z: { shape: [[1,1,0],[0,1,1]], color: '#FF0000', glow: '#FF0000' },
                    J: { shape: [[1,0,0],[1,1,1]], color: '#0000FF', glow: '#0000FF' },
                    L: { shape: [[0,0,1],[1,1,1]], color: '#FF7F00', glow: '#FF7F00' }
                };
            }
            
            setupGame() {
                this.board = Array(this.BOARD_HEIGHT).fill(null).map(() => Array(this.BOARD_WIDTH).fill(null));
                this.spawnPiece();
                this.spawnNextPiece();
                this.fallTime = 0;
                this.lines = 0;
                this.combo = 0;
                this.particles = [];
            }
            
            spawnPiece() {
                if (this.nextPiece) {
                    this.currentPiece = this.nextPiece;
                    this.spawnNextPiece();
                } else {
                    this.currentPiece = this.createRandomPiece();
                }
                
                this.currentPiece.x = Math.floor(this.BOARD_WIDTH / 2) - Math.floor(this.currentPiece.shape[0].length / 2);
                this.currentPiece.y = 0;
                
                this.updateGhostPiece();
                
                if (this.checkCollision()) {
                    this.gameOver();
                }
            }
            
            spawnNextPiece() {
                this.nextPiece = this.createRandomPiece();
            }
            
            createRandomPiece() {
                const pieces = Object.keys(this.tetrominoes);
                const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
                const tetromino = this.tetrominoes[randomPiece];
                
                return {
                    shape: JSON.parse(JSON.stringify(tetromino.shape)),
                    color: tetromino.color,
                    glow: tetromino.glow,
                    type: randomPiece,
                    x: 0,
                    y: 0
                };
            }
            
            updateGhostPiece() {
                if (!this.currentPiece) return;
                
                this.ghostPiece = {
                    shape: this.currentPiece.shape,
                    x: this.currentPiece.x,
                    y: this.currentPiece.y,
                    color: this.currentPiece.color
                };
                
                while (!this.checkCollision(this.ghostPiece, 0, 1)) {
                    this.ghostPiece.y++;
                }
            }
            
            checkCollision(piece = this.currentPiece, offsetX = 0, offsetY = 0) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const newX = piece.x + x + offsetX;
                            const newY = piece.y + y + offsetY;
                            
                            if (newX < 0 || newX >= this.BOARD_WIDTH || 
                                newY >= this.BOARD_HEIGHT ||
                                (newY >= 0 && this.board[newY][newX])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            rotatePiece() {
                const rotated = this.currentPiece.shape[0].map((_, i) => 
                    this.currentPiece.shape.map(row => row[i]).reverse()
                );
                
                const originalShape = this.currentPiece.shape;
                this.currentPiece.shape = rotated;
                
                if (!this.checkCollision()) {
                    soundSystem.playRotate();
                    this.updateGhostPiece();
                    this.createRotateParticles();
                } else {
                    // Wall kicks
                    const wallKicks = [[1, 0], [-1, 0], [0, -1], [2, 0], [-2, 0]];
                    let kicked = false;
                    
                    for (let [dx, dy] of wallKicks) {
                        if (!this.checkCollision(this.currentPiece, dx, dy)) {
                            this.currentPiece.x += dx;
                            this.currentPiece.y += dy;
                            kicked = true;
                            soundSystem.playRotate();
                            this.updateGhostPiece();
                            this.createRotateParticles();
                            break;
                        }
                    }
                    
                    if (!kicked) {
                        this.currentPiece.shape = originalShape;
                    }
                }
            }
            
            movePiece(dx, dy) {
                if (!this.checkCollision(this.currentPiece, dx, dy)) {
                    this.currentPiece.x += dx;
                    this.currentPiece.y += dy;
                    if (dx !== 0) {
                        soundSystem.playMove();
                        this.updateGhostPiece();
                    }
                    return true;
                }
                return false;
            }
            
            hardDrop() {
                let dropDistance = 0;
                while (this.movePiece(0, 1)) {
                    dropDistance++;
                }
                this.score += dropDistance * 2;
                soundSystem.playDrop();
                this.lockPiece();
            }
            
            lockPiece() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            const boardY = this.currentPiece.y + y;
                            const boardX = this.currentPiece.x + x;
                            if (boardY >= 0) {
                                this.board[boardY][boardX] = {
                                    color: this.currentPiece.color,
                                    glow: this.currentPiece.glow
                                };
                            }
                        }
                    }
                }
                
                this.clearLines();
                this.spawnPiece();
                this.canHold = true;
            }
            
            clearLines() {
                let linesCleared = 0;
                let clearedRows = [];
                
                for (let y = this.BOARD_HEIGHT - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== null)) {
                        clearedRows.push(y);
                        this.board.splice(y, 1);
                        this.board.unshift(Array(this.BOARD_WIDTH).fill(null));
                        linesCleared++;
                        y++; // Check the same line again
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.combo++;
                    
                    // Создание эффектов для очищенных линий
                    clearedRows.forEach(row => this.createLineClearEffect(row));
                    
                    // Счет
                    const baseScore = [0, 40, 100, 300, 1200][linesCleared];
                    const comboBonus = this.combo > 1 ? this.combo * 50 : 0;
                    this.score += (baseScore + comboBonus) * (this.level + 1);
                    
                    // Показать комбо
                    if (this.combo > 1) {
                        this.showComboEffect(this.combo);
                    }
                    
                    // Уровень
                    const newLevel = Math.floor(this.lines / 10) + 1;
                    if (newLevel > this.level) {
                        this.level = newLevel;
                        this.fallSpeed = Math.max(50, 800 - (this.level - 1) * 50);
                        soundSystem.playLevelUp();
                    }
                    
                    // Звуки
                    if (linesCleared === 4) {
                        soundSystem.playTetris();
                    } else {
                        soundSystem.playLineClear();
                    }
                } else {
                    this.combo = 0;
                }
                
                this.updateHUD();
            }
            
            createLineClearEffect(row) {
                for (let x = 0; x < this.BOARD_WIDTH; x++) {
                    for (let i = 0; i < 5; i++) {
                        this.particles.push({
                            x: (canvas.width - this.BOARD_WIDTH * this.CELL_SIZE) / 2 + x * this.CELL_SIZE + this.CELL_SIZE / 2,
                            y: (canvas.height - this.BOARD_HEIGHT * this.CELL_SIZE) / 2 + row * this.CELL_SIZE + this.CELL_SIZE / 2,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8 - 3,
                            life: 60,
                            maxLife: 60,
                            color: '#FFFFFF',
                            size: Math.random() * 3 + 1
                        });
                    }
                }
            }
            
            createRotateParticles() {
                const centerX = (canvas.width - this.BOARD_WIDTH * this.CELL_SIZE) / 2 + 
                              this.currentPiece.x * this.CELL_SIZE + this.CELL_SIZE;
                const centerY = (canvas.height - this.BOARD_HEIGHT * this.CELL_SIZE) / 2 + 
                              this.currentPiece.y * this.CELL_SIZE + this.CELL_SIZE;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    this.particles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 30,
                        maxLife: 30,
                        color: this.currentPiece.glow,
                        size: 2
                    });
                }
            }
            
            showComboEffect(combo) {
                const comboElement = document.createElement('div');
                comboElement.className = 'combo-effect';
                comboElement.textContent = `COMBO x${combo}`;
                comboElement.style.left = '50%';
                comboElement.style.top = '30%';
                comboElement.style.transform = 'translateX(-50%)';
                
                document.body.appendChild(comboElement);
                
                setTimeout(() => {
                    if (document.body.contains(comboElement)) {
                        document.body.removeChild(comboElement);
                    }
                }, 1000);
            }
            
            holdPiece() {
                if (!this.canHold) return;
                
                if (this.heldPiece === null) {
                    this.heldPiece = this.currentPiece.type;
                    this.spawnPiece();
                } else {
                    const temp = this.heldPiece;
                    this.heldPiece = this.currentPiece.type;
                    this.currentPiece = this.createPieceByType(temp);
                    this.currentPiece.x = Math.floor(this.BOARD_WIDTH / 2) - Math.floor(this.currentPiece.shape[0].length / 2);
                    this.currentPiece.y = 0;
                    this.updateGhostPiece();
                }
                
                this.canHold = false;
                soundSystem.playMove();
            }
            
            createPieceByType(type) {
                const tetromino = this.tetrominoes[type];
                return {
                    shape: JSON.parse(JSON.stringify(tetromino.shape)),
                    color: tetromino.color,
                    glow: tetromino.glow,
                    type: type,
                    x: 0,
                    y: 0
                };
            }
            
            update() {
                this.fallTime += 16;
                
                if (this.fallTime >= this.fallSpeed) {
                    if (!this.movePiece(0, 1)) {
                        this.lockPiece();
                    }
                    this.fallTime = 0;
                }
                
                // Управление
                if (keys['ArrowLeft']) {
                    this.movePiece(-1, 0);
                    keys['ArrowLeft'] = false;
                }
                if (keys['ArrowRight']) {
                    this.movePiece(1, 0);
                    keys['ArrowRight'] = false;
                }
                if (keys['ArrowDown']) {
                    if (this.movePiece(0, 1)) {
                        this.score += 1;
                    }
                }
                if (keys['Space']) {
                    this.hardDrop();
                    keys['Space'] = false;
                }
                if (keys['KeyA']) {
                    this.rotatePiece();
                    keys['KeyA'] = false;
                }
                if (keys['KeyB']) {
                    this.holdPiece();
                    keys['KeyB'] = false;
                }
                
                // Обновление частиц
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.3; // гравитация
                    particle.life--;
                    return particle.life > 0;
                });
                
                this.updateHUD();
            }
            
            draw() {
                // Очистка
                ctx.fillStyle = '#000011';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Фон игрового поля
                const offsetX = (canvas.width - this.BOARD_WIDTH * this.CELL_SIZE) / 2;
                const offsetY = (canvas.height - this.BOARD_HEIGHT * this.CELL_SIZE) / 2;
                
                ctx.save();
                ctx.translate(offsetX, offsetY);
                
                // Рамка поля
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 3;
                ctx.strokeRect(-3, -3, this.BOARD_WIDTH * this.CELL_SIZE + 6, this.BOARD_HEIGHT * this.CELL_SIZE + 6);
                
                // Сетка
                ctx.strokeStyle = '#333366';
                ctx.lineWidth = 1;
                for (let x = 0; x <= this.BOARD_WIDTH; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * this.CELL_SIZE, 0);
                    ctx.lineTo(x * this.CELL_SIZE, this.BOARD_HEIGHT * this.CELL_SIZE);
                    ctx.stroke();
                }
                for (let y = 0; y <= this.BOARD_HEIGHT; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * this.CELL_SIZE);
                    ctx.lineTo(this.BOARD_WIDTH * this.CELL_SIZE, y * this.CELL_SIZE);
                    ctx.stroke();
                }
                
                // Зафиксированные блоки
                for (let y = 0; y < this.BOARD_HEIGHT; y++) {
                    for (let x = 0; x < this.BOARD_WIDTH; x++) {
                        if (this.board[y][x]) {
                            this.drawEnhancedBlock(x, y, this.board[y][x].color, this.board[y][x].glow);
                        }
                    }
                }
                
                // Призрак текущего куска
                if (this.ghostPiece) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    for (let y = 0; y < this.ghostPiece.shape.length; y++) {
                        for (let x = 0; x < this.ghostPiece.shape[y].length; x++) {
                            if (this.ghostPiece.shape[y][x]) {
                                this.drawEnhancedBlock(this.ghostPiece.x + x, this.ghostPiece.y + y, this.ghostPiece.color, this.ghostPiece.color);
                            }
                        }
                    }
                    ctx.restore();
                }
                
                // Текущий кусок
                if (this.currentPiece) {
                    for (let y = 0; y < this.currentPiece.shape.length; y++) {
                        for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                            if (this.currentPiece.shape[y][x]) {
                                this.drawEnhancedBlock(this.currentPiece.x + x, this.currentPiece.y + y, this.currentPiece.color, this.currentPiece.glow);
                            }
                        }
                    }
                }
                
                ctx.restore();
                
                // Следующий кусок
                if (this.nextPiece) {
                    this.drawNextPiece();
                }
                
                // Удерживаемый кусок
                if (this.heldPiece) {
                    this.drawHeldPiece();
                }
                
                // Частицы
                this.particles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.life / particle.maxLife;
                    ctx.fillStyle = particle.color;
                    ctx.shadowColor = particle.color;
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
            
            drawEnhancedBlock(x, y, color, glowColor) {
                const blockX = x * this.CELL_SIZE;
                const blockY = y * this.CELL_SIZE;
                
                ctx.save();
                
                // Основной блок
                ctx.fillStyle = color;
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 10;
                ctx.fillRect(blockX + 1, blockY + 1, this.CELL_SIZE - 2, this.CELL_SIZE - 2);
                
                // Блик
                const gradient = ctx.createLinearGradient(blockX, blockY, blockX + this.CELL_SIZE, blockY + this.CELL_SIZE);
                gradient.addColorStop(0, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(blockX + 2, blockY + 2, this.CELL_SIZE - 4, this.CELL_SIZE - 4);
                
                // Рамка
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(blockX + 1, blockY + 1, this.CELL_SIZE - 2, this.CELL_SIZE - 2);
                
                ctx.restore();
            }
            
            drawNextPiece() {
                if (!this.nextPiece) return;
                
                const previewX = canvas.width - 120;
                const previewY = 50;
                
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(previewX - 10, previewY - 10, 100, 80);
                
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(previewX - 10, previewY - 10, 100, 80);
                
                ctx.fillStyle = '#00FFFF';
                ctx.font = '12px Press Start 2P';
                ctx.fillText('NEXT', previewX, previewY - 20);
                
                const piece = this.nextPiece;
                const startX = previewX + (80 - piece.shape[0].length * 15) / 2;
                const startY = previewY + (60 - piece.shape.length * 15) / 2;
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            ctx.fillStyle = piece.color;
                            ctx.shadowColor = piece.glow;
                            ctx.shadowBlur = 5;
                            ctx.fillRect(startX + x * 15, startY + y * 15, 13, 13);
                        }
                    }
                }
                
                ctx.restore();
            }
            
            drawHeldPiece() {
                const previewX = canvas.width - 120;
                const previewY = 150;
                
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(previewX - 10, previewY - 10, 100, 80);
                
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 2;
                ctx.strokeRect(previewX - 10, previewY - 10, 100, 80);
                
                ctx.fillStyle = '#FFFF00';
                ctx.font = '12px Press Start 2P';
                ctx.fillText('HOLD', previewX, previewY - 20);
                
                const piece = this.createPieceByType(this.heldPiece);
                const startX = previewX + (80 - piece.shape[0].length * 15) / 2;
                const startY = previewY + (60 - piece.shape.length * 15) / 2;
                
                ctx.globalAlpha = this.canHold ? 1 : 0.5;
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            ctx.fillStyle = piece.color;
                            ctx.shadowColor = piece.glow;
                            ctx.shadowBlur = 5;
                            ctx.fillRect(startX + x * 15, startY + y * 15, 13, 13);
                        }
                    }
                }
                
                ctx.restore();
            }
        }
        
        // Quantum Shift - Авторская игра
        class QuantumShiftGame extends BaseGame {
            constructor() {
                super();
                this.particles = [];
                this.dimensions = 3;
                this.currentDimension = 0;
                this.quantumField = [];
                this.player = { x: 5, y: 5, phase: 0 };
                this.targets = [];
                this.obstacles = [];
                this.phaseTimer = 0;
            }
            
            setupGame() {
                this.quantumField = Array(3).fill(null).map(() => 
                    Array(15).fill(null).map(() => Array(20).fill(0))
                );
                
                this.player = { x: 5, y: 5, phase: 0 };
                this.targets = [];
                this.obstacles = [];
                this.phaseTimer = 0;
                
                // Генерация уровня
                for (let d = 0; d < 3; d++) {
                    for (let i = 0; i < 5; i++) {
                        this.targets.push({
                            x: Math.floor(Math.random() * 20),
                            y: Math.floor(Math.random() * 15),
                            dimension: d,
                            collected: false
                        });
                    }
                    
                    for (let i = 0; i < 8; i++) {
                        this.obstacles.push({
                            x: Math.floor(Math.random() * 20),
                            y: Math.floor(Math.random() * 15),
                            dimension: d,
                            active: true
                        });
                    }
                }
            }
            
            update() {
                this.phaseTimer += 16;
                
                // Автоматическое переключение измерений
                if (this.phaseTimer > 3000) {
                    this.currentDimension = (this.currentDimension + 1) % 3;
                    this.phaseTimer = 0;
                    this.createQuantumEffect();
                }
                
                // Управление
                if (keys['ArrowLeft'] && this.player.x > 0) {
                    this.player.x--;
                    keys['ArrowLeft'] = false;
                }
                if (keys['ArrowRight'] && this.player.x < 19) {
                    this.player.x++;
                    keys['ArrowRight'] = false;
                }
                if (keys['ArrowUp'] && this.player.y > 0) {
                    this.player.y--;
                    keys['ArrowUp'] = false;
                }
                if (keys['ArrowDown'] && this.player.y < 14) {
                    this.player.y++;
                    keys['ArrowDown'] = false;
                }
                if (keys['Space']) {
                    this.currentDimension = (this.currentDimension + 1) % 3;
                    this.createQuantumEffect();
                    keys['Space'] = false;
                }
                
                // Сбор целей
                this.targets.forEach(target => {
                    if (!target.collected && 
                        target.x === this.player.x && 
                        target.y === this.player.y && 
                        target.dimension === this.currentDimension) {
                        target.collected = true;
                        this.score += 100;
                        soundSystem.playPickup();
                    }
                });
                
                // Проверка препятствий
                this.obstacles.forEach(obstacle => {
                    if (obstacle.active &&
                        obstacle.x === this.player.x && 
                        obstacle.y === this.player.y && 
                        obstacle.dimension === this.currentDimension) {
                        this.lives--;
                        obstacle.active = false;
                        this.createExplosionEffect(this.player.x, this.player.y);
                        soundSystem.playExplosion();
                        
                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                    }
                });
                
                // Проверка победы
                if (this.targets.every(target => target.collected)) {
                    this.level++;
                    this.setupGame();
                    soundSystem.playLevelUp();
                }
                
                // Обновление частиц
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    return particle.life > 0;
                });
                
                this.updateHUD();
            }
            
            createQuantumEffect() {
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: this.player.x * 30 + 15,
                        y: this.player.y * 30 + 15,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 30,
                        color: ['#FF00FF', '#00FFFF', '#FFFF00'][this.currentDimension]
                    });
                }
            }
            
            createExplosionEffect(x, y) {
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: x * 30 + 15,
                        y: y * 30 + 15,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 40,
                        color: '#FF0000'
                    });
                }
            }
            
            draw() {
                // Фон
                const colors = ['#001122', '#220011', '#112200'];
                ctx.fillStyle = colors[this.currentDimension];
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Сетка
                ctx.strokeStyle = ['#0066FF', '#FF0066', '#66FF00'][this.currentDimension];
                ctx.lineWidth = 1;
                for (let x = 0; x <= 20; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * 30, 0);
                    ctx.lineTo(x * 30, 450);
                    ctx.stroke();
                }
                for (let y = 0; y <= 15; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * 30);
                    ctx.lineTo(600, y * 30);
                    ctx.stroke();
                }
                
                // Цели
                this.targets.forEach(target => {
                    if (!target.collected && target.dimension === this.currentDimension) {
                        ctx.fillStyle = '#FFFF00';
                        ctx.shadowColor = '#FFFF00';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(target.x * 30 + 15, target.y * 30 + 15, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Препятствия
                this.obstacles.forEach(obstacle => {
                    if (obstacle.active && obstacle.dimension === this.currentDimension) {
                        ctx.fillStyle = '#FF0000';
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 8;
                        ctx.fillRect(obstacle.x * 30 + 5, obstacle.y * 30 + 5, 20, 20);
                    }
                });
                
                // Игрок
                const playerColors = ['#00FFFF', '#FF00FF', '#FFFF00'];
                ctx.fillStyle = playerColors[this.currentDimension];
                ctx.shadowColor = playerColors[this.currentDimension];
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.player.x * 30 + 15, this.player.y * 30 + 15, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Частицы
                this.particles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.life / 30;
                    ctx.fillStyle = particle.color;
                    ctx.shadowColor = particle.color;
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                // Индикатор измерения
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '16px Press Start 2P';
                ctx.fillText(`DIMENSION: ${this.currentDimension + 1}`, 10, 500);
                
                // Таймер фазы
                const phaseProgress = this.phaseTimer / 3000;
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(10, 520, 200, 10);
                ctx.fillStyle = playerColors[this.currentDimension];
                ctx.fillRect(10, 520, 200 * phaseProgress, 10);
            }
        }
        
        // Neon Runner - Авторская игра
        class NeonRunnerGame extends BaseGame {
            constructor() {
                super();
                this.player = { x: 3, y: 8, trail: [] };
                this.obstacles = [];
                this.powerups = [];
                this.neonTrails = [];
                this.speed = 2;
                this.distance = 0;
                this.lanes = 7;
                this.spawnTimer = 0;
            }
            
            setupGame() {
                this.player = { x: 3, y: 8, trail: [] };
                this.obstacles = [];
                this.powerups = [];
                this.neonTrails = [];
                this.speed = 2 + this.level * 0.5;
                this.distance = 0;
                this.spawnTimer = 0;
            }
            
            update() {
                this.distance += this.speed;
                this.spawnTimer++;
                
                // Управление
                if (keys['ArrowLeft'] && this.player.x > 0) {
                    this.player.x--;
                    keys['ArrowLeft'] = false;
                }
                if (keys['ArrowRight'] && this.player.x < this.lanes - 1) {
                    this.player.x++;
                    keys['ArrowRight'] = false;
                }
                
                // Спавн препятствий
                if (this.spawnTimer > Math.max(20, 60 - this.level * 5)) {
                    if (Math.random() < 0.7) {
                        this.obstacles.push({
                            x: Math.floor(Math.random() * this.lanes),
                            y: -2,
                            type: Math.random() < 0.5 ? 'wall' : 'laser'
                        });
                    }
                    
                    if (Math.random() < 0.3) {
                        this.powerups.push({
                            x: Math.floor(Math.random() * this.lanes),
                            y: -2,
                            type: Math.random() < 0.5 ? 'speed' : 'score'
                        });
                    }
                    
                    this.spawnTimer = 0;
                }
                
                // Обновление препятствий
                this.obstacles.forEach((obstacle, index) => {
                    obstacle.y += this.speed * 0.5;
                    
                    // Столкновения
                    if (Math.abs(obstacle.x - this.player.x) < 0.8 && 
                        Math.abs(obstacle.y - this.player.y) < 0.8) {
                        this.lives--;
                        this.obstacles.splice(index, 1);
                        this.createExplosion(this.player.x, this.player.y);
                        soundSystem.playExplosion();
                        
                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                    }
                    
                    if (obstacle.y > 15) {
                        this.obstacles.splice(index, 1);
                        this.score += 10;
                    }
                });
                
                // Обновление бонусов
                this.powerups.forEach((powerup, index) => {
                    powerup.y += this.speed * 0.5;
                    
                    if (Math.abs(powerup.x - this.player.x) < 0.8 && 
                        Math.abs(powerup.y - this.player.y) < 0.8) {
                        this.powerups.splice(index, 1);
                        
                        if (powerup.type === 'speed') {
                            this.speed += 0.5;
                        } else {
                            this.score += 100;
                        }
                        
                        soundSystem.playPickup();
                    }
                    
                    if (powerup.y > 15) {
                        this.powerups.splice(index, 1);
                    }
                });
                
                // Обновление следа
                this.player.trail.unshift({ x: this.player.x, y: this.player.y, life: 20 });
                if (this.player.trail.length > 20) {
                    this.player.trail.pop();
                }
                this.player.trail.forEach(segment => segment.life--);
                
                // Неоновые эффекты
                if (Math.random() < 0.1) {
                    this.neonTrails.push({
                        x: Math.random() * this.lanes,
                        y: -1,
                        color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                        life: 60
                    });
                }
                
                this.neonTrails = this.neonTrails.filter(trail => {
                    trail.y += this.speed * 0.3;
                    trail.life--;
                    return trail.life > 0 && trail.y < 16;
                });
                
                this.score += Math.floor(this.speed);
                
                // Увеличение уровня
                if (this.distance > this.level * 2000) {
                    this.level++;
                    soundSystem.playLevelUp();
                }
                
                this.updateHUD();
            }
            
            createExplosion(x, y) {
                for (let i = 0; i < 12; i++) {
                    this.neonTrails.push({
                        x: x + (Math.random() - 0.5) * 2,
                        y: y + (Math.random() - 0.5) * 2,
                        color: '#FF0000',
                        life: 30,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4
                    });
                }
            }
            
            draw() {
                // Черный фон
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const laneWidth = canvas.width / this.lanes;
                const cellHeight = canvas.height / 12;
                
                // Неоновые линии дорожки
                for (let i = 0; i <= this.lanes; i++) {
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#00FFFF');
                    gradient.addColorStop(1, '#0066FF');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#00FFFF';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(i * laneWidth, 0);
                    ctx.lineTo(i * laneWidth, canvas.height);
                    ctx.stroke();
                }
                
                // Неоновые эффекты
                this.neonTrails.forEach(trail => {
                    ctx.save();
                    ctx.globalAlpha = trail.life / 60;
                    ctx.fillStyle = trail.color;
                    ctx.shadowColor = trail.color;
                    ctx.shadowBlur = 15;
                    
                    if (trail.vx !== undefined) {
                        trail.x += trail.vx * 0.1;
                        trail.y += trail.vy * 0.1;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(trail.x * laneWidth + laneWidth / 2, trail.y * cellHeight, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                // След игрока
                this.player.trail.forEach((segment, index) => {
                    if (segment.life > 0) {
                        ctx.save();
                        ctx.globalAlpha = segment.life / 20;
                        ctx.fillStyle = '#00FF00';
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(segment.x * laneWidth + laneWidth / 2, segment.y * cellHeight, 8 - index * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                });
                
                // Препятствия
                this.obstacles.forEach(obstacle => {
                    ctx.save();
                    if (obstacle.type === 'wall') {
                        ctx.fillStyle = '#FF0000';
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 15;
                        ctx.fillRect(obstacle.x * laneWidth + 5, obstacle.y * cellHeight, laneWidth - 10, cellHeight - 5);
                    } else {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 5;
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x * laneWidth, obstacle.y * cellHeight);
                        ctx.lineTo((obstacle.x + 1) * laneWidth, obstacle.y * cellHeight + cellHeight);
                        ctx.stroke();
                    }
                    ctx.restore();
                });
                
                // Бонусы
                this.powerups.forEach(powerup => {
                    const color = powerup.type === 'speed' ? '#FFFF00' : '#FF00FF';
                    ctx.save();
                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(powerup.x * laneWidth + laneWidth / 2, powerup.y * cellHeight, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                // Игрок
                ctx.save();
                ctx.fillStyle = '#00FF00';
                ctx.shadowColor = '#00FF00';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.player.x * laneWidth + laneWidth / 2, this.player.y * cellHeight, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Детали игрока
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(this.player.x * laneWidth + laneWidth / 2 - 5, this.player.y * cellHeight - 3, 3, 0, Math.PI * 2);
                ctx.arc(this.player.x * laneWidth + laneWidth / 2 + 5, this.player.y * cellHeight - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                // Информация о скорости
                ctx.fillStyle = '#00FFFF';
                ctx.font = '16px Press Start 2P';
                ctx.fillText(`SPEED: ${this.speed.toFixed(1)}`, 10, canvas.height - 20);
            }
        }
        
        // Менеджер игр
        const gameClasses = {
            // Головоломки
            tetris: EnhancedTetrisGame,
            snake: class extends BaseGame {
                constructor() {
                    super();
                    this.snake = [{x: 10, y: 10}];
                    this.food = {x: 15, y: 15};
                    this.direction = {x: 1, y: 0};
                    this.gridSize = 20;
                    this.moveTimer = 0;
                }
                
                setupGame() {
                    this.snake = [{x: 10, y: 10}];
                    this.generateFood();
                    this.direction = {x: 1, y: 0};
                    this.moveTimer = 0;
                }
                
                generateFood() {
                    do {
                        this.food = {
                            x: Math.floor(Math.random() * 30),
                            y: Math.floor(Math.random() * 25)
                        };
                    } while (this.snake.some(segment => segment.x === this.food.x && segment.y === this.food.y));
                }
                
                update() {
                    // Управление
                    if (keys['ArrowLeft'] && this.direction.x === 0) {
                        this.direction = {x: -1, y: 0};
                    }
                    if (keys['ArrowRight'] && this.direction.x === 0) {
                        this.direction = {x: 1, y: 0};
                    }
                    if (keys['ArrowUp'] && this.direction.y === 0) {
                        this.direction = {x: 0, y: -1};
                    }
                    if (keys['ArrowDown'] && this.direction.y === 0) {
                        this.direction = {x: 0, y: 1};
                    }
                    
                    this.moveTimer++;
                    if (this.moveTimer >= Math.max(8, 20 - this.level)) {
                        const head = {
                            x: this.snake[0].x + this.direction.x,
                            y: this.snake[0].y + this.direction.y
                        };
                        
                        // Проверка границ
                        if (head.x < 0 || head.x >= 40 || head.y < 0 || head.y >= 30) {
                            this.gameOver();
                            return;
                        }
                        
                        // Проверка столкновения с собой
                        if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                            this.gameOver();
                            return;
                        }
                        
                        this.snake.unshift(head);
                        
                        // Проверка еды
                        if (head.x === this.food.x && head.y === this.food.y) {
                            this.score += 100;
                            this.generateFood();
                            soundSystem.playPickup();
                            
                            if (this.snake.length % 5 === 0) {
                                this.level++;
                                soundSystem.playLevelUp();
                            }
                        } else {
                            this.snake.pop();
                        }
                        
                        this.moveTimer = 0;
                    }
                    
                    this.updateHUD();
                }
                
                draw() {
                    // Фон
                    ctx.fillStyle = '#001100';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const cellSize = Math.min(canvas.width / 40, canvas.height / 30);
                    const offsetX = (canvas.width - 40 * cellSize) / 2;
                    const offsetY = (canvas.height - 30 * cellSize) / 2;
                    
                    // Сетка
                    ctx.strokeStyle = '#004400';
                    ctx.lineWidth = 1;
                    for (let x = 0; x <= 40; x++) {
                        ctx.beginPath();
                        ctx.moveTo(offsetX + x * cellSize, offsetY);
                        ctx.lineTo(offsetX + x * cellSize, offsetY + 30 * cellSize);
                        ctx.stroke();
                    }
                    for (let y = 0; y <= 30; y++) {
                        ctx.beginPath();
                        ctx.moveTo(offsetX, offsetY + y * cellSize);
                        ctx.lineTo(offsetX + 40 * cellSize, offsetY + y * cellSize);
                        ctx.stroke();
                    }
                    
                    // Змейка
                    this.snake.forEach((segment, index) => {
                        ctx.fillStyle = index === 0 ? '#00FF00' : '#008800';
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = index === 0 ? 10 : 5;
                        ctx.fillRect(
                            offsetX + segment.x * cellSize + 1,
                            offsetY + segment.y * cellSize + 1,
                            cellSize - 2,
                            cellSize - 2
                        );
                        
                        if (index === 0) {
                            // Глаза
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(offsetX + segment.x * cellSize + 3, offsetY + segment.y * cellSize + 3, 3, 3);
                            ctx.fillRect(offsetX + segment.x * cellSize + cellSize - 6, offsetY + segment.y * cellSize + 3, 3, 3);
                        }
                    });
                    
                    // Еда
                    ctx.fillStyle = '#FF0000';
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(
                        offsetX + this.food.x * cellSize + 1,
                        offsetY + this.food.y * cellSize + 1,
                        cellSize - 2,
                        cellSize - 2
                    );
                }
            },
            
            // Другие игры можно добавлять аналогично...
            quantum: QuantumShiftGame,
            neonrun: NeonRunnerGame,
            
            // Заглушки для остальных игр
            breakout: class extends BaseGame {
                draw() {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px Press Start 2P';
                    ctx.textAlign = 'center';
                    ctx.fillText('BREAKOUT', canvas.width/2, canvas.height/2);
                    ctx.fillText('Coming Soon!', canvas.width/2, canvas.height/2 + 40);
                }
            }
        };
        
        // Функции управления
        function initGameList() {
            Object.keys(allGames).forEach(category => {
                const container = document.getElementById(category + 'Games');
                if (container) {
                    allGames[category].forEach(game => {
                        const gameCard = document.createElement('div');
                        gameCard.className = 'game-card';
                        gameCard.dataset.gameId = game.id;
                        
                        gameCard.innerHTML = `
                            <div class="game-icon">${game.icon}</div>
                            <div class="game-title">${game.title}</div>
                        `;
                        
                        gameCard.addEventListener('click', () => selectGame(game));
                        container.appendChild(gameCard);
                    });
                }
            });
        }
        
        function selectGame(game) {
            document.querySelectorAll('.game-card').forEach(card => {
                card.classList.remove('active');
            });
            
            document.querySelector(`[data-game-id="${game.id}"]`).classList.add('active');
            document.getElementById('gameDescription').textContent = game.description;
            
            currentGame = game;
            stopGame();
        }
        
        function loadGame() {
            if (!currentGame || !gameClasses[currentGame.id]) return;
            
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingFill = document.getElementById('loadingFill');
            const loadingText = document.getElementById('loadingText');
            
            loadingScreen.style.display = 'flex';
            
            const loadingSteps = [
                'Initializing quantum matrix...',
                'Loading game assets...',
                'Compiling shaders...',
                'Optimizing for your device...',
                'Starting game engine...'
            ];
            
            let progress = 0;
            let stepIndex = 0;
            
            const loadingInterval = setInterval(() => {
                progress += Math.random() * 15 + 5;
                
                if (stepIndex < loadingSteps.length && progress > (stepIndex + 1) * 20) {
                    loadingText.textContent = loadingSteps[stepIndex];
                    stepIndex++;
                }
                
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(loadingInterval);
                    
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        actualStartGame();
                    }, 500);
                }
                
                loadingFill.style.width = progress + '%';
            }, 100);
        }
        
        function actualStartGame() {
            if (gameClasses[currentGame.id]) {
                activeGameInstance = new gameClasses[currentGame.id]();
                activeGameInstance.init();
                activeGameInstance.start();
                gameRunning = true;
                document.getElementById('startBtn').textContent = 'RUNNING';
                canvas.classList.add('game-transition');
                
                setTimeout(() => {
                    canvas.classList.remove('game-transition');
                }, 500);
            }
        }
        
        function startGame() {
            if (!currentGame) return;
            loadGame();
        }
        
        function pauseGame() {
            if (activeGameInstance && gameRunning) {
                activeGameInstance.pause();
                document.getElementById('pauseBtn').textContent = 
                    activeGameInstance.paused ? 'RESUME' : 'PAUSE';
            }
        }
        
        function resetGame() {
            if (activeGameInstance) {
                activeGameInstance.stop();
                activeGameInstance.init();
                gameRunning = false;
                document.getElementById('startBtn').textContent = 'START';
                document.getElementById('pauseBtn').textContent = 'PAUSE';
                hideOverlay();
            }
        }
        
        function stopGame() {
            if (activeGameInstance) {
                activeGameInstance.stop();
                activeGameInstance = null;
                gameRunning = false;
                document.getElementById('startBtn').textContent = 'START';
                document.getElementById('pauseBtn').textContent = 'PAUSE';
                hideOverlay();
                
                // Стартовый экран
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#00FF00');
                gradient.addColorStop(0.5, '#00FFFF');
                gradient.addColorStop(1, '#FF00FF');
                
                ctx.fillStyle = gradient;
                ctx.font = '48px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('MEGACONSOLE 30', canvas.width / 2, canvas.height / 2 - 60);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '20px Press Start 2P';
                ctx.fillText('SELECT GAME TO START', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '14px Press Start 2P';
                ctx.fillText('30 GAMES • ULTIMATE EXPERIENCE', canvas.width / 2, canvas.height / 2 + 40);
                
                ctx.font = '12px Press Start 2P';
                ctx.fillText('OPTIMIZED FOR PC & MOBILE', canvas.width / 2, canvas.height / 2 + 80);
            }
        }
        
        function showOverlay(title, text) {
            document.getElementById('overlayTitle').textContent = title;
            document.getElementById('overlayText').textContent = text;
            document.getElementById('gameOverlay').style.display = 'flex';
        }
        
        function hideOverlay() {
            document.getElementById('gameOverlay').style.display = 'none';
        }
        
        // Обработка событий
        document.addEventListener('keydown', (e) => {
            // Основные клавиши
            keys[e.code] = true;
            
            // Альтернативные клавиши
            const keyMap = {
                'KeyW': 'ArrowUp', 'KeyS': 'ArrowDown',
                'KeyA': 'ArrowLeft', 'KeyD': 'ArrowRight',
                'KeyH': 'ArrowLeft', 'KeyJ': 'ArrowDown',
                'KeyK': 'ArrowUp', 'KeyL': 'ArrowRight',
                'KeyI': 'ArrowUp', 'Comma': 'ArrowDown',
                'KeyO': 'ArrowLeft', 'Period': 'ArrowRight'
            };
            
            if (keyMap[e.code]) {
                keys[keyMap[e.code]] = true;
            }
            
            // Предотвращение прокрутки
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            
                        if (keyMap[e.code]) {
                keys[keyMap[e.code]] = true;
            }
        });
        
        // Виртуальные кнопки для мобильных устройств
        document.querySelectorAll('.dpad-btn, .action-btn').forEach(btn => {
            // Мышь события
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const key = btn.dataset.key;
                if (key) {
                    keys[key] = true;
                    btn.style.transform = 'scale(0.9)';
                }
            });
            
            btn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                const key = btn.dataset.key;
                if (key) {
                    keys[key] = false;
                    btn.style.transform = 'scale(1)';
                }
            });
            
            btn.addEventListener('mouseleave', (e) => {
                const key = btn.dataset.key;
                if (key) {
                    keys[key] = false;
                    btn.style.transform = 'scale(1)';
                }
            });
            
            // Touch события для мобильных
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const key = btn.dataset.key;
                if (key) {
                    keys[key] = true;
                    btn.style.transform = 'scale(0.9)';
                    btn.style.background = 'linear-gradient(45deg, #6a4a4a, #5a3a3a)';
                }
            });
            
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                const key = btn.dataset.key;
                if (key) {
                    keys[key] = false;
                    btn.style.transform = 'scale(1)';
                    btn.style.background = '';
                }
            });
            
            btn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                const key = btn.dataset.key;
                if (key) {
                    keys[key] = false;
                    btn.style.transform = 'scale(1)';
                    btn.style.background = '';
                }
            });
        });
        
        // Системные кнопки
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!gameRunning && currentGame) {
                startGame();
            }
        });
        
        document.getElementById('pauseBtn').addEventListener('click', pauseGame);
        document.getElementById('resetBtn').addEventListener('click', resetGame);
        
        // Быстрое переключение игр клавишами
        document.addEventListener('keydown', (e) => {
            // Цифровые клавиши для быстрого выбора игр
            if (e.key >= '1' && e.key <= '9') {
                const gameIndex = parseInt(e.key) - 1;
                const allGamesList = Object.values(allGames).flat();
                if (gameIndex < allGamesList.length) {
                    selectGame(allGamesList[gameIndex]);
                }
                e.preventDefault();
            }
            
            // Shift + цифра для мгновенного запуска
            if (e.shiftKey && e.key >= '1' && e.key <= '9') {
                const gameIndex = parseInt(e.key) - 1;
                const allGamesList = Object.values(allGames).flat();
                if (gameIndex < allGamesList.length) {
                    selectGame(allGamesList[gameIndex]);
                    setTimeout(() => startGame(), 100);
                }
                e.preventDefault();
            }
            
            // Q/E для переключения игр
            if (e.code === 'KeyQ' && !gameRunning) {
                navigateGames(-1);
                e.preventDefault();
            }
            if (e.code === 'KeyE' && !gameRunning) {
                navigateGames(1);
                e.preventDefault();
            }
            
            // ESC для выхода из игры
            if (e.code === 'Escape' && gameRunning) {
                if (activeGameInstance && !activeGameInstance.paused) {
                    pauseGame();
                } else {
                    stopGame();
                }
                e.preventDefault();
            }
            
            // F для полноэкранного режима
            if (e.code === 'KeyF') {
                toggleFullscreen();
                e.preventDefault();
            }
        });
        
        function navigateGames(direction) {
            const allGamesList = Object.values(allGames).flat();
            const currentIndex = allGamesList.findIndex(game => game.id === currentGame?.id);
            
            if (currentIndex !== -1) {
                const newIndex = (currentIndex + direction + allGamesList.length) % allGamesList.length;
                selectGame(allGamesList[newIndex]);
                
                // Прокрутка к выбранной игре
                const gameCard = document.querySelector(`[data-game-id="${allGamesList[newIndex].id}"]`);
                if (gameCard) {
                    gameCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error enabling fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        // Адаптивный ресайз canvas
        function resizeCanvas() {
            const container = document.querySelector('.game-display');
            const containerRect = container.getBoundingClientRect();
            
            // Поддержание соотношения сторон 4:3
            let newWidth = containerRect.width - 40;
            let newHeight = (newWidth * 3) / 4;
            
            if (newHeight > containerRect.height - 40) {
                newHeight = containerRect.height - 40;
                newWidth = (newHeight * 4) / 3;
            }
            
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
            
            // Обновление HiDPI
            const dpr = window.devicePixelRatio || 1;
            canvas.width = 800 * dpr;
            canvas.height = 600 * dpr;
            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = false;
        }
        
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });
        
        // Предотвращение зума на мобильных
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Система сохранения прогресса
        class SaveSystem {
            static save(gameId, data) {
                try {
                    const saveData = JSON.stringify(data);
                    localStorage.setItem(`megaconsole_${gameId}`, saveData);
                    return true;
                } catch (e) {
                    console.log('Save failed:', e);
                    return false;
                }
            }
            
            static load(gameId) {
                try {
                    const saveData = localStorage.getItem(`megaconsole_${gameId}`);
                    return saveData ? JSON.parse(saveData) : null;
                } catch (e) {
                    console.log('Load failed:', e);
                    return null;
                }
            }
            
            static saveSettings(settings) {
                this.save('settings', settings);
            }
            
            static loadSettings() {
                return this.load('settings') || {
                    volume: 0.3,
                    controls: 'default',
                    theme: 'dark'
                };
            }
        }
        
        // Расширенная система достижений
        class AchievementSystem {
            constructor() {
                this.achievements = {
                    first_game: { name: 'First Steps', description: 'Play your first game', unlocked: false },
                    tetris_master: { name: 'Tetris Master', description: 'Clear 4 lines at once', unlocked: false },
                    speed_demon: { name: 'Speed Demon', description: 'Reach level 10 in any game', unlocked: false },
                    collector: { name: 'Game Collector', description: 'Try 10 different games', unlocked: false },
                    perfectionist: { name: 'Perfectionist', description: 'Get 100,000 points in any game', unlocked: false },
                    quantum_master: { name: 'Quantum Master', description: 'Master dimension shifting', unlocked: false },
                    neon_runner: { name: 'Neon Runner', description: 'Survive 1000 distance units', unlocked: false }
                };
                
                this.loadProgress();
            }
            
            unlock(achievementId) {
                if (this.achievements[achievementId] && !this.achievements[achievementId].unlocked) {
                    this.achievements[achievementId].unlocked = true;
                    this.showAchievementNotification(this.achievements[achievementId]);
                    this.saveProgress();
                    soundSystem.playLevelUp();
                }
            }
            
            showAchievementNotification(achievement) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(45deg, #ffd700, #ffed4e);
                    color: #000;
                    padding: 15px 20px;
                    border-radius: 10px;
                    font-family: 'Press Start 2P';
                    font-size: 10px;
                    z-index: 1000;
                    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
                    animation: achievementSlide 3s ease-out forwards;
                `;
                
                notification.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">🏆 ACHIEVEMENT UNLOCKED!</div>
                    <div style="font-size: 8px;">${achievement.name}</div>
                    <div style="font-size: 6px; margin-top: 3px;">${achievement.description}</div>
                `;
                
                // Добавляем CSS анимацию
                if (!document.getElementById('achievement-styles')) {
                    const style = document.createElement('style');
                    style.id = 'achievement-styles';
                    style.textContent = `
                        @keyframes achievementSlide {
                            0% { transform: translateX(100%); opacity: 0; }
                            20% { transform: translateX(0); opacity: 1; }
                            80% { transform: translateX(0); opacity: 1; }
                            100% { transform: translateX(100%); opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 3000);
            }
            
            saveProgress() {
                SaveSystem.save('achievements', this.achievements);
            }
            
            loadProgress() {
                const saved = SaveSystem.load('achievements');
                if (saved) {
                    this.achievements = { ...this.achievements, ...saved };
                }
            }
        }
        
        const achievementSystem = new AchievementSystem();
        
        // Улучшенная система частиц
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }
            
            create(x, y, options = {}) {
                const particle = {
                    x: x,
                    y: y,
                    vx: options.vx || (Math.random() - 0.5) * 10,
                    vy: options.vy || (Math.random() - 0.5) * 10,
                    life: options.life || 60,
                    maxLife: options.life || 60,
                    color: options.color || '#FFFFFF',
                    size: options.size || Math.random() * 5 + 2,
                    gravity: options.gravity || 0.2,
                    friction: options.friction || 0.98,
                    glow: options.glow || false
                };
                
                this.particles.push(particle);
            }
            
            createExplosion(x, y, count = 15, colors = ['#FF0000', '#FF6600', '#FFFF00']) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const speed = Math.random() * 8 + 4;
                    
                    this.create(x, y, {
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        life: 40 + Math.random() * 20,
                        size: Math.random() * 6 + 3,
                        glow: true
                    });
                }
            }
            
            update() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += particle.gravity;
                    particle.vx *= particle.friction;
                    particle.vy *= particle.friction;
                    particle.life--;
                    
                    return particle.life > 0;
                });
            }
            
            render(ctx) {
                this.particles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.life / particle.maxLife;
                    
                    if (particle.glow) {
                        ctx.shadowColor = particle.color;
                        ctx.shadowBlur = 10;
                    }
                    
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
            }
        }
        
        const globalParticles = new ParticleSystem();
        
        // Система настроек
        function createSettingsPanel() {
            const panel = document.createElement('div');
            panel.id = 'settingsPanel';
            panel.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(145deg, #2a2a3a, #1a1a2a);
                border: 3px solid #00ff64;
                border-radius: 15px;
                padding: 30px;
                z-index: 1000;
                display: none;
                font-family: 'Press Start 2P';
                color: #00ff64;
                min-width: 400px;
            `;
            
            panel.innerHTML = `
                <h3 style="text-align: center; margin-bottom: 20px;">⚙️ SETTINGS</h3>
                
                <div style="margin: 15px 0;">
                    <label>🔊 Volume: <span id="volumeValue">30%</span></label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="30" 
                           style="width: 100%; margin-top: 5px;">
                </div>
                
                <div style="margin: 15px 0;">
                    <label>🎮 Control Scheme:</label>
                    <select id="controlScheme" style="width: 100%; margin-top: 5px; background: #1a1a2a; color: #00ff64; border: 1px solid #00ff64; padding: 5px;">
                        <option value="arrows">Arrow Keys</option>
                        <option value="wasd">WASD</option>
                        <option value="vim">Vim (HJKL)</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                
                <div style="margin: 15px 0;">
                    <label>🎨 Theme:</label>
                    <select id="themeSelect" style="width: 100%; margin-top: 5px; background: #1a1a2a; color: #00ff64; border: 1px solid #00ff64; padding: 5px;">
                        <option value="dark">Dark Green</option>
                        <option value="blue">Cyber Blue</option>
                        <option value="red">Matrix Red</option>
                        <option value="purple">Neon Purple</option>
                    </select>
                </div>
                
                <div style="text-align: center; margin-top: 25px;">
                    <button id="saveSettings" style="background: #00ff64; color: #000; border: none; padding: 10px 20px; margin: 0 10px; cursor: pointer; font-family: 'Press Start 2P'; font-size: 8px;">SAVE</button>
                    <button id="closeSettings" style="background: #ff6464; color: #000; border: none; padding: 10px 20px; margin: 0 10px; cursor: pointer; font-family: 'Press Start 2P'; font-size: 8px;">CLOSE</button>
                </div>
            `;
            
            document.body.appendChild(panel);
            
            // Обработчики событий
            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                const value = e.target.value;
                document.getElementById('volumeValue').textContent = value + '%';
                soundSystem.masterVolume = value / 100;
            });
            
            document.getElementById('saveSettings').addEventListener('click', () => {
                const settings = {
                    volume: document.getElementById('volumeSlider').value,
                    controls: document.getElementById('controlScheme').value,
                    theme: document.getElementById('themeSelect').value
                };
                
                SaveSystem.saveSettings(settings);
                applyTheme(settings.theme);
                panel.style.display = 'none';
            });
            
            document.getElementById('closeSettings').addEventListener('click', () => {
                panel.style.display = 'none';
            });
            
            return panel;
        }
        
        function applyTheme(theme) {
            const themes = {
                dark: { primary: '#00ff64', secondary: '#ff6464', accent: '#ffff64' },
                blue: { primary: '#00aaff', secondary: '#ff6600', accent: '#ffff00' },
                red: { primary: '#ff4444', secondary: '#44ff44', accent: '#ffff44' },
                purple: { primary: '#aa44ff', secondary: '#44ffaa', accent: '#ffaa44' }
            };
            
            const selectedTheme = themes[theme];
            if (selectedTheme) {
                document.documentElement.style.setProperty('--primary-color', selectedTheme.primary);
                document.documentElement.style.setProperty('--secondary-color', selectedTheme.secondary);
                document.documentElement.style.setProperty('--accent-color', selectedTheme.accent);
            }
        }
        
        // Добавим кнопку настроек
        const settingsBtn = document.createElement('div');
        settingsBtn.className = 'system-btn';
        settingsBtn.textContent = 'SET';
        settingsBtn.style.fontSize = '8px';
        settingsBtn.addEventListener('click', () => {
            document.getElementById('settingsPanel').style.display = 'block';
        });
        document.querySelector('.system-controls').appendChild(settingsBtn);
        
        // Инициализация
        function init() {
            console.log('🎮 Initializing MegaConsole 30...');
            
            // Создание панели настроек
            createSettingsPanel();
            
            // Загрузка настроек
            const settings = SaveSystem.loadSettings();
            soundSystem.masterVolume = settings.volume / 100;
            applyTheme(settings.theme);
            
            // Инициализация списка игр
            initGameList();
            
            // Автоматический выбор первой игры
            const firstGame = allGames.puzzle[0];
            if (firstGame) {
                selectGame(firstGame);
            }
            
            // Адаптивный canvas
            resizeCanvas();
            
            // Инициализация звука при первом взаимодействии
            document.addEventListener('click', function initSound() {
                soundSystem.initAudio();
                if (soundSystem.audioContext) {
                    soundSystem.audioContext.resume();
                }
                achievementSystem.unlock('first_game');
                document.removeEventListener('click', initSound);
            }, { once: true });
            
            // Стартовый экран
            stopGame();
            
            // Анимация частиц на заднем фоне
            function backgroundAnimation() {
                if (!gameRunning) {
                    if (Math.random() < 0.02) {
                        globalParticles.create(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            {
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                color: '#00ff64',
                                life: 120,
                                size: 1,
                                glow: true
                            }
                        );
                    }
                    
                    globalParticles.update();
                    globalParticles.render(ctx);
                }
                
                requestAnimationFrame(backgroundAnimation);
            }
            backgroundAnimation();
            
            console.log('✅ MegaConsole 30 initialized successfully!');
            console.log('🎯 Available games:', Object.values(allGames).flat().length);
            console.log('⌨️ Use number keys 1-9 for quick game selection');
            console.log('🚀 Use Shift+Number for instant game launch');
            console.log('⚙️ Press F for fullscreen mode');
        }
        
        // Запуск консоли
        init();
        
        // Service Worker для оффлайн работы
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript;base64,' + btoa(`
                const CACHE_NAME = 'megaconsole-v1';
                
                self.addEventListener('install', (event) => {
                    event.waitUntil(
                        caches.open(CACHE_NAME).then((cache) => {
                            return cache.addAll(['/']);
                        })
                    );
                });
                
                self.addEventListener('fetch', (event) => {
                    event.respondWith(
                        caches.match(event.request).then((response) => {
                            return response || fetch(event.request);
                        })
                    );
                });
            `)).then(() => {
                console.log('📱 Service Worker registered for offline play');
            }).catch(() => {
                console.log('❌ Service Worker registration failed');
            });
        }
        
        // Экспорт для отладки
        window.MegaConsole = {
            version: '3.0',
            gameCount: Object.values(allGames).flat().length,
            selectGame,
            startGame,
            achievementSystem,
            soundSystem,
            saveSystem: SaveSystem
        };
        
        console.log(`
        ╔══════════════════════════════════════╗
        ║        MEGACONSOLE 30 LOADED!        ║
        ║                                      ║
        ║  🎮 30 Games Ready                   ║
        ║  📱 Mobile Optimized                 ║
        ║  🎵 Advanced Sound System            ║
        ║  🏆 Achievement System               ║
        ║  💾 Auto-Save Progress               ║
        ║  ⚙️ Customizable Settings            ║
        ║                                      ║
        ║  Ready for Ultimate Gaming!          ║
        ╚══════════════════════════════════════╝
        `);
    </script>
</body>
</html>
